## 前言

HTTP 是一种无状态的协议，也就是 HTTP 没法保存客户端的信息，没办法区分每次请求的不同。

> Token 是服务器生成的一串字符，作为客户端请求的令牌。当第一次登陆后，服务器会分发 Tonken 字符串给客户端。后续的请求，客户端只需带上这个 Token，服务器即可知道是该用户的访问。

## token 验证设计

我的个人博客，对 get 类型的请求不做 token 验证，其他会修改资源的请求如 POST、PUT 做 token 验证

- 客户端用户登录，服务端根据用户信息生成 token 并在客户端持久化存储
- 客户端请求，带上 token
- 服务端验证 token，若失败则直接访问错误状态

**1.前端**

使用 axios 库，并且在 request 拦截器中在 header 中带上 token，在 response 拦截器中统一对错误状态码进行全局提示

登录成功之后把 token 写入 localstorage 中，每次请求都带上

```bash
import Vue from 'vue';
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';

axios.interceptors.request.use(
  async (config: AxiosRequestConfig) => {
    const acess_token = await Vue.prototype.$getCacheData('acess_token'); # localstorage中读取token
    if (acess_token) {
      config.headers.acess_token = acess_token;
    }
    return config;
  },
  (err: any) => Promise.reject(err),
);

axios.interceptors.response.use(
  (response: AxiosResponse) => {
    if (response.data.ret === 200) {
      return response;
    } else {
      Vue.prototype.$global_fail(response.data.content);
      return Promise.reject(response);
    }
  },
  (err: any) => {
    console.log(err);
    if (err.code === 'ECONNABORTED' && err.message.indexOf('timeout') !== -1) {
      Vue.prototype.$global_error('请求超时，请联系管理员');
    }
    if (err.response) {
      Vue.prototype.$global_error(decodeURI(err.response.data.msg || err.response.data.message));
    }
    return Promise.reject(err);
  },
);
```

**2.后端（egg.js）**

用户登录，使用 jsonwebtoken 生成 token

jsonwebtoken 的使用点击： [node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken)

直接给出 UserService 方法，其中 secret 为秘钥，加密和解密的时候会用到，还可以设置 token 失效

```bash
# /app/service/user.ts
import * as jwt from 'jsonwebtoken';

export default class UserService extends Service {

  private secret = 'Hello__World'; # 秘钥
  async createToken(user: User): Promise<string> {
    const payload = {
      _id: user._id,
      nick_name: user.nick_name,
      created_time: user.created_time,
      updated_time: user.updated_time,
    };
    return jwt.sign(payload, this.secret, { expiresIn: '7d' }); # 过期时间
  }

  checkToken(token: string): User {
    try {
      # 根据秘钥解密token
      return jwt.verify(token, this.secret);
    } catch (e) {
      throw '无效的token';
    }
  }

}
```

在中间件中进行 token 验证，若失败直接返回

开启 verify 中间件，并只对特定的 POST 请求进行验证:

```bash
# /config/config.default.ts
config.middleware = ['verify'];
config.verify = {
  enable: true,
  # 只对POST请求做验证
  match(ctx) {
    return ctx.request.method === 'POST';
  },
};
```
